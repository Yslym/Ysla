package socks5server

import (
	"errors" 
	"fmt" 
	"io" 
	"log" 
	"net" 
	"strconv"
)

type FirstMesssage struct {
	Version byte 
	Method  byte
}

func NewFirstMessage(v byte, m byte) *FirstMesssage {
	messsage := FirstMesssage{
		Version : v, 
		Method	: m,
	} 
	return &messsage
} 
func (self *FirstMesssage) Bytes() []byte {
	return []byte{self.Version, self.Method}
}

type Socks5server struct {
	IP   string 
	Port int
}

func NewSocks5Server(ip string, port int) *Socks5server {
	return &Socks5server{ip, port}
}

func (self *Socks5server) Run() error {
	listen, err := net.Listen("tcp",self.IP+":"+strconv.Itoa(self.Port)) 
	if err != nil {
		log.Printf("failed to listen: %v", err) 
		return err
	} 
	defer listen.Close() 
	log.Printf("successful run socks5 server on %s:%d\n", self.IP, self.Port) 
	for {
		conn, err := listen.Accept() 
		if err != nil {
			log.Printf("failed to accept connection: %v",err) 
			continue
		} 
		go handle_client(conn)
	}
}

// 1st Layer 
func handle_client(conn net.Conn) {
	defer conn.Close()
	log.Println("###########################################") 
	err :=	auth(conn) // process the auth process 
	if err != nil {
		log.Printf("failed to auth %v", err) 
		conn.Close() 
		return
	} 
	log.Println("[+] Finish Auth	Success") 
	msg, err := req(conn)
	if err != nil {
		log.Printf("failed to req %v", err)
		response, _ := buildSecondResponse(0x05, 0x08,
		0x00,0xff,[]byte{0xff,0xff,0xff,0xff}, 0xffff)
		conn.Write(response.Bytes()) 
		conn.Close() 
		return
	} 
	log.Println("[+] Finish requ Success")

	err = proxy(conn, msg) 
	if err != nil {
		log.Printf("failed to proxy %v", err) 
		conn.Close() 
		return
	} 
	log.Println("[+] Finish Proxy Success")

	return
} 
func connect_to_domain(domain []byte,port uint16) (net.Conn,error){
	addr := string(domain) 
	tcp_addr := fmt.Sprintf("%s:%d",addr,port)
	log.Println("[proxy] domain address ",tcp_addr)

	return net.Dial("tcp",tcp_addr)
} 
func toNet(i uint16) uint16{
	return (i<<8 | i>>8)

} 
func proxy(conn net.Conn, msg *SecondMessage) error {
	log.Println("[proxy] start proxy") 
	log.Println("[proxy] message:",msg) 
	var targetConn net.Conn 
	var err error

	if msg.Atype == 0x03{
		targetConn, err = connect_to_domain(msg.Addr,msg.Port)
	}else{
		target := fmt.Sprintf("%d.%d.%d.%d:%d", msg.Addr[0],msg.Addr[1], msg.Addr[2], msg.Addr[3], msg.Port)
		targetConn, err = net.Dial("tcp", target)
	} 
	if err != nil {
		log.Printf("failed to dial target: %v", err)
		secondResponse, _ := buildSecondResponse(0x05,0x01, 0x00, 0x01,msg.Addr, msg.Port)
		conn.Write(secondResponse.Bytes()) 
		return errors.New("failed to dial target")
	}

	log.Println("[proxy] build tcp connect success")

	localAddr := targetConn.LocalAddr().(*net.TCPAddr) 
	addrBytes := localAddr.IP.To4()

	response, _ := buildSecondResponse(0x05, 0x00, 0x00, 0x01,addrBytes,toNet(uint16(localAddr.Port)))
	log.Println("[proxy] send to response ",response.Bytes())

	conn.Write(response.Bytes())

	defer targetConn.Close() 
	log.Println("[proxu]Start ForWarding")

	go io.Copy(conn, targetConn) 
	io.Copy(targetConn, conn)

	log.Println("[+] end forward") 
	conn.Close() 
	targetConn.Close()
	return nil
}

type SecondMessage struct {
	Version byte 
	Cmd     byte 
	Rsv	  byte 
	Atype   byte 
	Addr    []byte
	Port	uint16
}

// "for responsed" 
func buildSecondResponse(version byte, rep byte,rsv byte, atype byte, addr []byte, port uint16) (*SecondMessage, error) {
	return &SecondMessage{version, rep, rsv, atype, addr, port}, nil
} 
func (self *SecondMessage) Bytes() []byte { // return net_bytes
	var buff = make([]byte, 6+len(self.Addr)) 
	buff[0] = self.Version
	buff[1] = self.Cmd 
	buff[2] = self.Rsv 
	buff[3] = self.Atype
	copy(buff[4:], self.Addr) 
	buff[4+len(self.Addr)] = byte(self.Port& 0xff00) 
	buff[4+len(self.Addr)+1] = byte(self.Port & 0x00ff)

	return buff
} 
func builfSecondMessage(io io.ReadWriter) (*SecondMessage, error) {
	var buf [4]byte 
	io.Read(buf[:4]) 
	var msg SecondMessage = SecondMessage{buf[0], buf[1], buf[2], buf[3], nil, 0} 
	switch buf[3] { case 0x01: // ipv4
		var addrBuf [4]byte 
		io.Read(addrBuf[:4]) // read ip addre
		msg.Addr = net.IP(addrBuf[:4]) 
		var portbuf [2]byte
		io.Read(portbuf[:2]) 
		msg.Port = uint16(portbuf[0])<<8 |uint16(portbuf[1]) 
		return &msg, nil
	case 0x04: // ipv6
		var addrBuf []byte = make([]byte, 16) 
		io.Read(addrBuf)
		msg.Addr = net.IP(addrBuf[:16]) 
		var portbuf [2]byte
		io.Read(portbuf[:2]) 
		msg.Port = uint16(portbuf[0])<<8 |uint16(portbuf[1]) 
		return &msg, nil
	case 0x03: // domain
		var domainLen [1]byte 
		io.Read(domainLen[:1]) 
		var domain[]byte = make([]byte, domainLen[0]) 
		io.Read(domain)
		msg.Addr = net.IP(domain[:]) 
		var portbuf [2]byte
		io.Read(portbuf[:2]) 
		msg.Port = uint16(portbuf[0])<<8 |uint16(portbuf[1]) 
		return &msg, nil
	default:
		log.Printf("trigger default it is %d",buf[3])
		log.Printf("%v",buf) 
		return nil, errors.New("invalidcommand in build Second Message")
	}

}

/* *

		   -----+-------+------+----------+----------+
	       |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
	       +----+-----+-------+------+----------+----------+
	       | 1  |  1  | X'00' |  1	 | Variable |	 2     |
	       +----+-----+-------+------+----------+----------+
*/

func req(conn net.Conn) (*SecondMessage, error) {
	message, err := builfSecondMessage(conn) 
	if err != nil {
		return nil, err
	} 
	log.Println("[req]build req message ",message) 
	if message.Version != 0x05 {
		return nil, errors.New("invalid Second Socks version")
	} 
	log.Println("[req]req version success") 
	if message.Cmd != 0x01 {
		return nil, errors.New("invalid command in req socks5 we do not supported")
	} 
	log.Println("[req]req cmd success") 
	if message.Rsv != 0x00 {
		return nil, errors.New("invalid rsv")
	} 
	log.Println("[req]req rsv success") 
	if message.Atype != 0x01{
		log.Println("not ip ",message.Atype)
	} 
	return message, nil
}

func auth(conn net.Conn) error {
	var buf [2]byte 
	conn.Read(buf[:])

	if buf[0] != 0x5 {
		msg := NewFirstMessage(0x05, 0xff) // refuse socks connect , version not supported 
		conn.Write(msg.Bytes())
		return errors.New("version is not V5")
	} 
	log.Println("[auth] Version Verify Success") 
	var nmethod int =int(buf[1]) 
	var buff []byte = make([]byte, nmethod)

	_, err := io.ReadFull(conn, buff) 
	if err != nil {
		return err
	} 
	log.Println("[auth] nmethod Recive Success ",buff) 
	for _, i := range buff {
		if 0x00 == i { // No password auth or password
			conn.Write(NewFirstMessage(0x05, 0x00).Bytes())
			return nil
		} 
		if 0x01 == i { // password auth
			conn.Write(NewFirstMessage(0x05, 0xff).Bytes())
			return errors.New("Temporay No Implement")
		}

	} // have a talk // Use No Auth

	return errors.New("No Supported Method")
}
